# 이것이 자바다

- 데이터 타입
    - 기본 타입 : 정수형, 실수형, 논리형
    - 참조 타입 : 배열, 열거형, 클래스, 인터페이스
- 메모리 영역
    - 메소드 영역
        - 바이트코드 파일을 읽은 내용이 저장되는 영역
        - 클래스 별 상수, 정적 필드, 메소드 및 생성자 코드 등이 저장됨
    - 힙 영역
        - 객체가 생성되는 영역
    - 스택 영역
        - 메서드 호출 시 생성되는 프레임이 저장되는 영역
        - 메서드 호출이 끝나면 프레임은 자동 제거
        - 프레임 내부에 로컬 변수 스택이 존재

- 예외란? 프로그램 실행 도중에 발생하는 오류
- public class는 소스 파일 명과 동일한 클래스로만 선언 가능하다
    - 따라서, 한 소스 파일 당 최대 하나의 public class만 선언할 수 있다
- 클래스 용도
    - 라이브러리 클래스 : 실행할 수 없으며, 다른 클래스에서 이용하는 클래스
    - 실행 클래스 : main() 메서드를 포함한 클래스
- 필드와 변수의 차이
    - 필드는 클래스 블록에서 선언되고, 변수는 생성자 및 메서드 블럭에서 선언된다
    - 필드는 객체 내외부에서 사용되고, 변수는 블록 내부에서만 사용된다
- 클래스 내부에서 생성자 호출 방법 : this(param1, param2, …);
- 가변 길이 매개변수
    - int sum(int… values)
    - 전달 인자는 자동으로 배열 항목으로 변환되어 전달된다
    - 따라서, 가변 길이 매개변수는 배열로 처리된다
- 자바는 클래스 로더를 이용해서 클래스를 메서드 영역에 저장하고 사용한다
- 정적(static) 블록 : 클래스가 메모리로 로딩될 때 자동으로 실행되는 블록, 클래스에 여러 정적 블록이 존재하는 경우 선언된 순서대로 실행
- 상수 선언 : static final
- 패키지
    - 클래스를 식별하는 용도로 사용되는 클래스
    - 각 클래스의 전체 이름에 포함됨
    - 패키지 디렉토리는 클래스를 컴파일하는 과정에서 자동으로 생성됨
- 같은 패키지에 있는 클래스는 import문 없이 사용 가능하지만, 다른 패키지에 있는 클래스를 사용하는 경우 import 패키지명.클래스 선언이 필요
    - 클래스 전체 이름(패키지명.클래스명)을 사용하는 경우, import문은 필요 없음
- Getter, Setter 사용 이유
    - 객체의 무결성을 보장하
- 오버라이딩 규칙
    - 메서드 시그니처가 일치해야 한다
    - 접근 제한을 더 강하게 오버라이딩 할 수 없다(pulic → private 변경 불가)
    - 새로운 예외를 throws 할 수 없다
- @Override 어노테이션 : 컴파일 타임에 부모 클래스의 메서드를 정확히 오버라이딩 했는지 체크함
- 부모 클래스의 오버라이딩 된 메서드를 호출하려면 자식 클래스의 객체에서 super 키워드로 호출 가능
- final 키워드 적용
    - 필드 : 초기화 이후 변경 불가
    - 클래스 : 상속 불가
    - 메서드 : 오버라이딩 불가
- protected는 같은 패키지에서 혹은 다른 패키지에 존재하는 자식 클래스의 객체 내부에서만 접근 가능. 자식 클래스에서 부모 클래스에 대해 직접 new 키워드 사용 불가. 즉, 자식 클래스의 객체를 통해서만 접근 가능.
- 자식 클래스의 객체를 부모 클래스로 타입 캐스팅 했을 때, 자식 클래스에서 오버라이딩된 메서드가 있다면 부모 메서드 대신 오버라이딩된 메서드가 호출된다.
- 부모 타입에서 자식 타입으로는 강제 변환만 가능
    - 강제 변환이 가능한 경우는, 자식 객체가 부모 타입으로 변환된 후 다시 자식 타입으로 변환할 때만 가능
- 다형성
    - 사용 방법은 동일하지만 실행 결과가 다양하게 나오는 성질
    - 다형성을 구현하기 위해서는 ‘부모 타입으로의 자동 형변환’과 ‘메소드 재정의’가 필요하다
    - 필드 다형성과 매개변수 다형성이 있다
- 추상 클래스
    - 객체를 생성할 수 있는 실체 클래스들의 공통적인 필드나 메소드를 추출해서 선언한 클래스
    - 추상 클래스는 실체 클래스의 부모 클래스이며, new 연산자를 사용해서 객체를 직접 생성할 수 없다
- 추상 메서드는 추상 클래스와 인터페이스에 포함되는 메서드로, 자식 클래스 혹은 구현 클래스에서 특정 메서드의 구현을 강제하는데 사용됩니다.
- 봉인된 클래스(sealed class)
    - 무분별한 자식 클래스의 생성을 방지하기 위해 Java 15에서 도입된 기능
    - public sealed class Person permits Employee, Manager, Director { … }
    - 봉인된 클래스를 상속하려면 다음의 방법으로 가능
        - public final class Employee extends Person { … }
        - public non-sealed class Manager extends Person { … } : 봉인을 해제
        - public sealed class Director permits Executive { … }

# 인터페이스

- 구성 요소
    - public 상수 필드
    - public 추상 메소드, 디폴트 메소드, 정적 메소드
    - private 메소드, 정적 메소드 : 디폴트와 정적 메소드들의 중복 코드를 줄이기 위해 사용
- 인터페이스에 선언된 필드는 모두 public static final 특성을 갖기 때문에 생략하더라도 자동으로 컴파일 과정에서 붙게 된다
- 인터페이스의 추상메서드는 모두 public이다. 따라서 구현 클래스에서 public보다 더 낮은 접근 제한으로 재정의할 수 없다
- 인터페이스에는 완전한 실행 코드를 가진 디폴트 메소드를 선언할 수 있다. 디폴트 메소드는 default 키워드가 리턴 타입 앞에 붙는다.
- 구현 클래스에서 디폴트 메소드를 재정의 할 때에는, public 접근 제한자를 반드시 붙여야하고 default 키워드를 생략해야 한다.
- 인터페이스는 다형성을 구현하는 주된 기술로, 현업에서는 상속보다 인터페이스를 통해서 다형성을 구현하는 경우가 더 많다.
- 클래스와 마찬가지로 자바 15부터는 sealed 키워드를 사용하여 봉인된 인터페이스로 선언할 수 있다.
- 자바 12부터는 instanceof 연산의 결과가 true일 경우, 우측 타입 변수를 사용할 수 있기 때문에 강제 타입 변환이 필요 없다
    
    ```java
    public void ride(Vehicle vehicle) {
    	/*if(vehicle instanceof Bus) {
    		Bus bus = (Bus) vehicle;
    		bus.checkFare();
    	}*/
    
    	if(vehicle instanceof Bus bus) {
    		bus.checkFare();
    	}
    
    	vehicle.run();
    }
    ```
    

# 중첩 선언과 익명 객체

## 중첩 클래스

- 클래스가 여러 클래스와 관계를 맺는 경우에는 독립적으로 선언하는 것이 좋으나, 특정 클래스만 관계를 맺을 경우에는 중첩 클래스로 선언하는 것이 유지보수에 도움이 되는 경우가 많다.
- 중첩 클래스란 클래스 내부에 선언한 클래스를 말하는데, 중첩 클래스를 사용하면 클래스의 멤버를 쉽게 사용할 수 있고 외부에는 중첩 관계 클래스를 감춤으로써 코드의 복잡성을 줄일 수 있다는 장점이 있다.
- 선언 위치에 따른 분류
    - 인스턴스 멤버 클래스 : 클래스의 멤버로서 선언되는 중첩 클래스
    - 정적 멤버 클래스 : 클래스의 멤버로서 선언되는 정적 중첩 클래스
    - 로컬 클래스 : 생성자 혹은 메소드 내부에서 선언되는 중첩 클래스
- 인스턴스 멤버 클래스
    
    ```java
    public class A {
    	[public | private] class B {}
    }
    ```
    
    - 주로 A 클래스 내부에서 사용되므로 private 접근 제한을 갖는 것이 일반적
    - A 객체를 생성해야만 B 객체를 생성할 수 있기 때문에, 인스턴스 필드값, 생성자, 인스턴스 메소드에서 생성할 수 있다.
- 정적 멤버 클래스
    
    ```java
    public class A {
    	[public | private] static class B {
    	}
    }
    ```
    
    - 정적 멤버 클래스는 주로 외부에서 사용되는 경우가 많기 때문에, 주로 default 또는 public 접근 제한을 가진다.
    - A 객체를 생성하지 않아도 B 객체를 생성할 수 있기 때문에, A 클래스 내부 어디든 객체를 생성할 수 있다.
    - 외부에서 생성 : A.B b = new A.B();
- 로컬 클래스
    - 로컬 클래스는 생성자와 메소드가 실행될 동안에만 객체를 생성할 수 있다
    - 로컬 클래스에서 생성자 혹은 메소드의 매개변수와 지역변수를 사용하는 경우, 해당 변수는 final 이어야 한다. 이는 로컬 클래스 내부에서 값을 변경하지 못하도록 제한하기 때문이다. Java 8 이후부터는 final 키워드를 생략해도 되지만, 이전에는 final 키워드를 반드시 붙여야 했다.
- 중첩 클래스 내부에서 바깥 클래스 객체에 접근하려면 바깥 클래스 이름에 this를 붙여주면 된다.
    
    ```java
    public class A {
    	
    	String field = "A-field";
    
    	void method() {
    		System.out.println("A-method");
    	}
    
    	class B {
    
    		String field = "B-field";
    
    		void method() {
    			System.out.println("B-method");
    		}
    
    		void printA() {
    			System.out.println(A.this.field);
    			A.this.method();
    		}
    	}
    }
    ```
    

## 중첩 인터페이스

- 클래스의 멤버로 선언된 인터페이스
- 안드로이드와 같은 UI 프로그램에서 이벤트를 처리할 목적으로 많이 활용된다
    
    ```java
    public class Button {
    	
    	public static interface ClickListener {
    		void onClick();
    	}
    
    	private ClickListener clickListener;
    
    	public void setClickListener(ClickListener clickListener) {
    		this.clickListener = clickListener;
    	}
    
    	public void click() {
    		this.clickListener.onClick();
    	}
    
    }
    ```
    
    ```java
    public class ButtonExample {
    	
    	public static void main(String[] args) {
    		Button btnOk = new Button();
    
    		class OkListener implements Button.ClickListener {
    			@Override
    			public void onClick() {
    				System.out.println("OK Button Clicked");
    			}
    		}
    
    		btnOk.setClickListener(new OkListener());
    
    		btnOk.click();
    	}
    
    }
    ```
    

## 익명 객체

- 이름이 없는 객체
- 주로 필드값, 로컬 변수값, 매개변수값으로 사용된다
- 익명 객체는 클래스를 상속하거나 인터페이스를 구현해야만 생성할 수 있다
- 익명 객체에서는 주로 메소드를 재정의하는 코드가 온다
- 명시적으로 클래스를 선언하지 않기 때문에 쉽게 객체를 생성할 수 있다는 장점이 있다
- 익명 자식 객체 : 클래스를 상속해서 만든 익명 객체
    
    ```java
    public class Tire {
    	public void roll() {
    		System.out.println("일반 타이어 roll");
    	}
    }
    ```
    
    ```java
    public class Car {
    	private Tire tire1 = new Tire();
    
    	private Tire tire2 = new Tire() {
    		@Override
    		public void roll() {
    			System.out.println("익명 자식 타이어 객체2 roll");
    		}
    	};
    
    	public void run1() {
    		tire1.roll();
    		tire2.roll();
    	}
    
    	public void run2(Tire tire) {
    		tire.roll();
    	}
    }
    ```
    
    ```java
    public class CarExample {
    
    	public static void main(String[] args) {
    		Car car = new Car;
    
    		car.run1();
    
    		car.run2(new Tire() {
    			@Override
    			public void roll() {
    				System.out.println("익명 자식 타이어 객체3 roll");
    			}
    		});
    	}
    }
    ```
    
- 익명 구현 객체 : 인터페이스를 구현해서 만든 익명 객체
    
    ```java
    public interface RemoteControl {
    		void turnOn();
    		void turnOff();
    }
    ```
    
    ```java
    public class Home {
    
    	private RemoteControl rc = new Remotecontrol() {
    		@Override
    		public void turnOn() {
    			System.out.println("TV를 켭니다.");
    		}
    	};
    
    	public void use1() {
    		rc.turnOn();
    		rc.turnOff();
    	}
    
    	public void use2(RemoteControl rc) {
    		rc.turnOn();
    		rc.turnOff();
    	}
    }
    ```
    
    ```java
    public class HomeExample {
    	public static void main(String[] args) {
    		Home home = new Home();
    
    		home.use1();
    
    		RemoteControl airConditionerRc = new RemoteControl() {
    			@Override
    			public void turnOn() {
    				System.out.println("난방을 켭니다.");
    			}
    
    			@Override
    			public void turnOff() {
    				System.out.println("난방을 끕니다.");
    			}
    		};
    
    		home.use2(airConditionerRc);
    	}
    }
    ```
    

# 라이브러리와 모듈

# 예외 처리

- 에러(Error) : 컴퓨터 하드웨어의 고장으로 인해 응용프로그램 실행 오류가 발생하는 것
- 예외(Exception) : 잘못된 사용 또는 코딩으로 인한 오류
- 예외가 발생되면 프로그램이 곧바로 종료된다는 점에서는 에러와 동일하지만, 예외 처리를 통해 계속 실행 상태를 유지할 수 있다.
- 일반 예외(Exception) : 컴파일러가 예외 처리 코드 여부를 검사하는 예외, Runtime Exception 외의 예외 클래스 (체크 예외)
- 실행 예외(Runtime Exception) : 컴파일러가 예외 처리 코드 여부를 검사하지 않는 예외 (언체크 예외)
- 자바는 예외가 발생하면 예외 클래스로부터 객체를 생성한다. 이 객체는 예외 처리 시 사용된다.
- 자바의 모든 에러와 예외 클래스는 Throwable을 상속받아 만들어지고, 예외 클래스는 추가적으로 Exception 클래스를 상속받는다.
- 자바의 예외 처리 코드는 try-catch-finally 블록으로 구성된다.
- finally 블록은 항상 실행되는데, 심지어 try 블록과 catch 블록에서 return 문을 사용하더라도 finally 블록은 항상 실행된다.
- catch 블록은 위에서부터 차례대로 검사 대상이 되는데, 가장 먼저 매칭되는 블록 하나만 실행된다. 따라서, 처리해야할 예외 클래스들이 상속 관계에 있을 때는 하위 클래스의 catch 블록을 먼저 작성하고 상위 클래스의 catch 블록을 나중에 작성해야 한다.
- try-with-resources 블록
    - try 괄호에 리소스를 명시하면, try 블록이 정상적으로 실행을 완료했거나 도중에 예외가 발생하면 자동으로 리소스의 close() 메소드가 호출된다.
    - 이때, 리소스는 java.lang.AutoCloseable 인터페이스를 구현하여 close() 메소드를 재정의한 리소스여야 한다.
    - Java 8 이전 버전은 try 괄호 안에서 리소스 변수를 반드시 선언해야 했지만, Java 9 이후부터는 외부 리소스 변수를 사용할 수 있다.
        
        ```java
        FileInputStream fis1 = new FileInputStream("file1.txt");
        FileInputStream fis2 = new FileInputStream("file2.txt");
        
        try(fis1; fis2) {
        	...
        } catch(IOException e) {
        	...
        }
        ```
        
- throws
    - 메소드를 호출한 곳으로 예외를 떠넘길 때 사용하는 키워드
    - 나열해야 할 예외 클래스가 많은 경우에는 throws Exception 혹은 throws Throwable 만으로 모든 예외를 간단히 떠넘길 수도 있다
    - main() 메소드에서 throws 키워드를 사용해서 예외를 떠넘기면 결국 JVM이 최종적으로 예외처리를 한다. 이때, JVM은 예외의 내용을 콘솔에 출력하는 것으로 예외를 처리한다.
- 사용자 정의 예외
    
    ```java
    public class InsufficientBalanceException extends Exception {
    	public InsufficientBalanceException() {
    	}
    
    	public InsufficientBalanceException(String message) {
    		super(message);
    	}
    }
    ```
    
    - 체크 예외는 Exception 클래스를 상속, 언체크 예외는 RuntimeException 클래스를 상속하여 정의
    - 사용자 정의 예외 클래스에는 기본 생성자와 예외 메시지를 입력받는 생성자를 선언해준다.
    - 예외 메시지는 부모 생성자의 매개값으로 넘겨주는데, 이는 Exception 클래스의 getMessage()에서 리턴값으로 사용되기 때문이다.
