- 데이터 타입
    - 기본 타입 : 정수형, 실수형, 논리형
    - 참조 타입 : 배열, 열거형, 클래스, 인터페이스
- 메모리 영역
    - 메소드 영역
        - 바이트코드 파일을 읽은 내용이 저장되는 영역
        - 클래스 별 상수, 정적 필드, 메소드 및 생성자 코드 등이 저장됨
    - 힙 영역
        - 객체가 생성되는 영역
    - 스택 영역
        - 메서드 호출 시 생성되는 프레임이 저장되는 영역
        - 메서드 호출이 끝나면 프레임은 자동 제거
        - 프레임 내부에 로컬 변수 스택이 존재

- 예외란? 프로그램 실행 도중에 발생하는 오류
- public class는 소스 파일 명과 동일한 클래스로만 선언 가능하다
    - 따라서, 한 소스 파일 당 최대 하나의 public class만 선언할 수 있다
- 클래스 용도
    - 라이브러리 클래스 : 실행할 수 없으며, 다른 클래스에서 이용하는 클래스
    - 실행 클래스 : main() 메서드를 포함한 클래스
- 필드와 변수의 차이
    - 필드는 클래스 블록에서 선언되고, 변수는 생성자 및 메서드 블럭에서 선언된다
    - 필드는 객체 내외부에서 사용되고, 변수는 블록 내부에서만 사용된다
- 클래스 내부에서 생성자 호출 방법 : this(param1, param2, …);
- 가변 길이 매개변수
    - int sum(int… values)
    - 전달 인자는 자동으로 배열 항목으로 변환되어 전달된다
    - 따라서, 가변 길이 매개변수는 배열로 처리된다
- 자바는 클래스 로더를 이용해서 클래스를 메서드 영역에 저장하고 사용한다
- 정적(static) 블록 : 클래스가 메모리로 로딩될 때 자동으로 실행되는 블록, 클래스에 여러 정적 블록이 존재하는 경우 선언된 순서대로 실행
- 상수 선언 : static final
- 패키지
    - 클래스를 식별하는 용도로 사용되는 클래스
    - 각 클래스의 전체 이름에 포함됨
    - 패키지 디렉토리는 클래스를 컴파일하는 과정에서 자동으로 생성됨
- 같은 패키지에 있는 클래스는 import문 없이 사용 가능하지만, 다른 패키지에 있는 클래스를 사용하는 경우 import 패키지명.클래스 선언이 필요
    - 클래스 전체 이름(패키지명.클래스명)을 사용하는 경우, import문은 필요 없음
- Getter, Setter 사용 이유
    - 객체의 무결성을 보장하
- 오버라이딩 규칙
    - 메서드 시그니처가 일치해야 한다
    - 접근 제한을 더 강하게 오버라이딩 할 수 없다(pulic → private 변경 불가)
    - 새로운 예외를 throws 할 수 없다
- @Override 어노테이션 : 컴파일 타임에 부모 클래스의 메서드를 정확히 오버라이딩 했는지 체크함
- 부모 클래스의 오버라이딩 된 메서드를 호출하려면 자식 클래스의 객체에서 super 키워드로 호출 가능
- final 키워드 적용
    - 필드 : 초기화 이후 변경 불가
    - 클래스 : 상속 불가
    - 메서드 : 오버라이딩 불가
- protected는 같은 패키지에서 혹은 다른 패키지에 존재하는 자식 클래스의 객체 내부에서만 접근 가능. 자식 클래스에서 부모 클래스에 대해 직접 new 키워드 사용 불가. 즉, 자식 클래스의 객체를 통해서만 접근 가능.
- 자식 클래스의 객체를 부모 클래스로 타입 캐스팅 했을 때, 자식 클래스에서 오버라이딩된 메서드가 있다면 부모 메서드 대신 오버라이딩된 메서드가 호출된다.
- 부모 타입에서 자식 타입으로는 강제 변환만 가능
    - 강제 변환이 가능한 경우는, 자식 객체가 부모 타입으로 변환된 후 다시 자식 타입으로 변환할 때만 가능
- 다형성
    - 사용 방법은 동일하지만 실행 결과가 다양하게 나오는 성질
    - 다형성을 구현하기 위해서는 ‘부모 타입으로의 자동 형변환’과 ‘메소드 재정의’가 필요하다
    - 필드 다형성과 매개변수 다형성이 있다
- 추상 클래스
    - 객체를 생성할 수 있는 실체 클래스들의 공통적인 필드나 메소드를 추출해서 선언한 클래스
    - 추상 클래스는 실체 클래스의 부모 클래스이며, new 연산자를 사용해서 객체를 직접 생성할 수 없다
- 추상 메서드는 추상 클래스와 인터페이스에 포함되는 메서드로, 자식 클래스 혹은 구현 클래스에서 특정 메서드의 구현을 강제하는데 사용됩니다.
- 봉인된 클래스(sealed class)
    - 무분별한 자식 클래스의 생성을 방지하기 위해 Java 15에서 도입된 기능
    - public sealed class Person permits Employee, Manager, Director { … }
    - 봉인된 클래스를 상속하려면 다음의 방법으로 가능
        - public final class Employee extends Person { … }
        - public non-sealed class Manager extends Person { … } : 봉인을 해제
        - public sealed class Director permits Executive { … }
